// DarkPool contract interaction hook for ELLALLE platform
import { CONTRACT_CONFIG } from '@/lib/env';
import { useCallback, useEffect, useState } from 'react';

interface DarkPoolState {
  isConnected: boolean;
  balance: { available: string; locked: string } | null;
  markets: string[];
  systemStatus: {
    exists: boolean;
    paused: boolean;
    marketCount: number;
    owner: string;
  } | null;
  loading: boolean;
  error: string | null;
}

interface UseDarkPoolReturn extends DarkPoolState {
  connect: () => Promise<void>;
  deposit: (amount: string) => Promise<string>;
  withdraw: (amount: string) => Promise<string>;
  checkBalance: (address: string) => Promise<void>;
  refreshSystemStatus: () => Promise<void>;
  getStoredMarkets: () => Promise<void>;
}

// Utility functions for web3 operations
const toWei = (amount: string): string => {
  const num = parseFloat(amount);
  return (BigInt(Math.floor(num * 1e18))).toString();
};

const fromWei = (amountWei: string): string => {
  try {
    const bigIntValue = BigInt(amountWei);
    const ethValue = Number(bigIntValue) / 1e18;
    return ethValue.toFixed(4);
  } catch {
    return '0.0000';
  }
};

const toHex = (num: number | bigint): string => `0x${num.toString(16)}`;

// Contract ABI fragments for the functions we need
const CONTRACT_ABI = {
  // HederaDarkPoolManager functions
  depositToDarkpool: '0xd0d9f0ef',
  withdrawFromDarkpool: '0x8c7b6fb0',
  checkDarkPoolAddresses: '0x5c60da1b',
  getUserDarkPoolBalance: '0x7bb98a68',
  // DarkpoolPerpDEX functions
  balanceOf: '0x70a08231',
  owner: '0x8da5cb5b',
  paused: '0x5c975abb',
};

// Encode function call with parameters
const encodeFunctionCall = (signature: string, params: string[] = []): string => {
  if (params.length === 0) {
    return signature;
  }
  // For simple cases, just append padded parameters
  const paddedParams = params.map(param => {
    if (param.startsWith('0x')) {
      return param.slice(2).padStart(64, '0');
    }
    return param.padStart(64, '0');
  }).join('');
  return signature + paddedParams;
};

export const useDarkPool = (): UseDarkPoolReturn => {
  const [state, setState] = useState<DarkPoolState>({
    isConnected: false,
    balance: null,
    markets: [
      'BTC/USD', 'ETH/USD', 'SOL/USD', 'HBAR/USD',
      'ADA/USD', 'AVAX/USD', 'DOT/USD', 'MATIC/USD'
    ],
    systemStatus: {
      exists: true,
      paused: false,
      marketCount: 8,
      owner: '0xD42ba3BB3B2908dc10E499D318Ab867359ca9743',
    },
    loading: false,
    error: null,
  });

  // Get ethereum provider
  const getProvider = useCallback(() => {
    if (typeof window !== 'undefined' && window.ethereum) {
      return window.ethereum;
    }
    throw new Error('No Ethereum provider found. Please install MetaMask.');
  }, []);

  // Connect to DarkPool
  const connect = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const provider = getProvider();
      
      // Request account access
      const accounts = await provider.request({ method: 'eth_requestAccounts' });
      
      if (!accounts || accounts.length === 0) {
        throw new Error('No accounts found');
      }

      // Check network
      const chainId = await provider.request({ method: 'eth_chainId' });
      const expectedChainId = toHex(297); // Hedera Previewnet
      
      if (chainId !== expectedChainId) {
        try {
          // Try to switch network
          await provider.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: expectedChainId }],
          });
        } catch (switchError: any) {
          // If switch fails, try to add the network
          if (switchError.code === 4902) {
            await provider.request({
              method: 'wallet_addEthereumChain',
              params: [{
                chainId: expectedChainId,
                chainName: 'Hedera Previewnet',
                nativeCurrency: {
                  name: 'HBAR',
                  symbol: 'HBAR',
                  decimals: 18,
                },
                rpcUrls: ['https://previewnet.hashio.io/api'],
                blockExplorerUrls: ['https://hashscan.io/previewnet'],
              }],
            });
          } else {
            throw switchError;
          }
        }
      }

      setState(prev => ({ 
        ...prev, 
        isConnected: true, 
        loading: false,
        error: null 
      }));

      // Auto-refresh system status
      await refreshSystemStatus();
      
    } catch (error: any) {
      setState(prev => ({
        ...prev,
        loading: false,
        error: error.message || 'Failed to connect to DarkPool',
        isConnected: false,
      }));
    }
  }, []);

  // Deposit HBAR to DarkPool via DarkpoolPerpDEX contract directly
  const deposit = useCallback(async (amount: string): Promise<string> => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const provider = getProvider();
      const accounts = await provider.request({ method: 'eth_accounts' });
      
      if (!accounts || accounts.length === 0) {
        throw new Error('No wallet connected');
      }

      // Convert amount to wei (hex)
      const amountWei = toWei(amount);
      const amountHex = `0x${BigInt(amountWei).toString(16)}`;
      
      console.log('Depositing:', { amount, amountWei, amountHex });

      // Get current gas price from network
      const gasPrice = await provider.request({ method: 'eth_gasPrice' });
      
      // Call d0e30db0 (deposit()) on DarkpoolPerpDEX contract directly
      const txParams = {
        from: accounts[0],
        to: CONTRACT_CONFIG.darkpoolPerpDEX, // Use main contract instead of manager
        value: amountHex,
        data: '0xd0e30db0', // deposit() function signature
        gas: toHex(300000), // More reasonable gas limit
        gasPrice: gasPrice, // Use network gas price
      };
      
      console.log('Transaction params:', txParams);
      
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [txParams],
      });

      console.log('Deposit transaction hash:', txHash);

      // Wait for transaction confirmation and refresh balance
      setTimeout(async () => {
        try {
          await checkBalance(accounts[0]);
        } catch (error) {
          console.error('Error refreshing balance after deposit:', error);
        }
      }, 3000);
      
      setState(prev => ({ ...prev, loading: false }));
      return txHash;
      
    } catch (error: any) {
      console.error('Deposit error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error.message || 'Deposit failed',
      }));
      throw error;
    }
  }, []);

  // Withdraw from DarkPool via DarkpoolPerpDEX contract directly
  const withdraw = useCallback(async (amount: string): Promise<string> => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const provider = getProvider();
      const accounts = await provider.request({ method: 'eth_accounts' });
      
      if (!accounts || accounts.length === 0) {
        throw new Error('No wallet connected');
      }

      // Convert amount to wei and encode as parameter
      const amountWei = toWei(amount);
      const amountHex = BigInt(amountWei).toString(16).padStart(64, '0');
      
      console.log('Withdrawing:', { amount, amountWei, amountHex });

      // Get current gas price from network
      const gasPrice = await provider.request({ method: 'eth_gasPrice' });
      
      // Call withdraw(uint256 amount) on DarkpoolPerpDEX
      const txParams = {
        from: accounts[0],
        to: CONTRACT_CONFIG.darkpoolPerpDEX, // Use main contract
        value: '0x0',
        data: '0x2e1a7d4d' + amountHex, // withdraw() function with amount parameter
        gas: toHex(300000),
        gasPrice: gasPrice, // Use network gas price
      };
      
      console.log('Withdrawal transaction params:', txParams);
      
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [txParams],
      });

      console.log('Withdrawal transaction hash:', txHash);

      // Wait for transaction confirmation and refresh balance
      setTimeout(async () => {
        try {
          await checkBalance(accounts[0]);
        } catch (error) {
          console.error('Error refreshing balance after withdrawal:', error);
        }
      }, 3000);
      
      setState(prev => ({ ...prev, loading: false }));
      return txHash;
      
    } catch (error: any) {
      console.error('Withdrawal error:', error);
      setState(prev => ({
        ...prev,
        loading: false,
        error: error.message || 'Withdrawal failed',
      }));
      throw error;
    }
  }, []);

  // Check user balance from the DarkPool contract directly
  const checkBalance = useCallback(async (address: string) => {
    if (!address) return;
    
    try {
      const provider = getProvider();
      
      // Call f8b2cb4f (getUserBalance(address)) on DarkpoolPerpDEX contract
      const userAddressHex = address.toLowerCase().slice(2).padStart(64, '0');
      const callData = '0xf8b2cb4f' + userAddressHex; // getUserBalance function
      
      console.log('Checking balance for:', address);
      console.log('Call data:', callData);
      
      const result = await provider.request({
        method: 'eth_call',
        params: [{
          to: CONTRACT_CONFIG.darkpoolPerpDEX, // Use main contract
          data: callData,
        }, 'latest'],
      });
      
      console.log('Balance call result:', result);
      
      if (result && result !== '0x' && result.length >= 130) { // Must have at least 64 bytes for two uint256 values
        // Parse the result - expecting tuple (uint256, uint256) for (available, locked)
        const balanceData = result.slice(2); // Remove 0x prefix
        
        // Extract first 32 bytes (available balance)
        const availableHex = '0x' + balanceData.slice(0, 64);
        const availableWei = BigInt(availableHex).toString();
        const availableEth = fromWei(availableWei);
        
        // Extract second 32 bytes (locked balance) 
        const lockedHex = '0x' + balanceData.slice(64, 128);
        const lockedWei = BigInt(lockedHex).toString();
        const lockedEth = fromWei(lockedWei);
        
        setState(prev => ({
          ...prev,
          balance: { 
            available: availableEth, 
            locked: lockedEth
          },
          error: null, // Clear any previous errors
        }));
        
        console.log('Balance updated:', { available: availableEth, locked: lockedEth }, 'HBAR');
        
        // Return the balance for immediate use
        return { available: availableEth, locked: lockedEth };
      } else {
        // No balance or first time user
        const defaultBalance = { available: '0.0000', locked: '0.0000' };
        setState(prev => ({
          ...prev,
          balance: defaultBalance,
          error: null,
        }));
        console.log('No balance found, setting to default');
        return defaultBalance;
      }
    } catch (error: any) {
      console.error('Balance check error:', error);
      // Set default balance on error to avoid blocking UI
      const defaultBalance = { available: '0.0000', locked: '0.0000' };
      setState(prev => ({
        ...prev,
        balance: defaultBalance,
        error: `Balance check failed: ${error.message}`,
      }));
      return defaultBalance;
    }
  }, []);
      setState(prev => ({
        ...prev,
        balance: { available: '0.0000', locked: '0.0000' },
        error: `Balance check failed: ${error.message}`,
      }));
    }
  }, []);

  // Refresh system status from contracts
  const refreshSystemStatus = useCallback(async () => {
    try {
      const provider = getProvider();
      
      // Check if DarkPool contract exists and get basic info
      console.log('Refreshing system status...');
      
      // Call checkDarkPoolAddresses() on HederaDarkPoolManager
      const addressCheckResult = await provider.request({
        method: 'eth_call',
        params: [{
          to: CONTRACT_CONFIG.hederaDarkPoolManager,
          data: CONTRACT_ABI.checkDarkPoolAddresses,
        }, 'latest'],
      });
      
      console.log('Address check result:', addressCheckResult);
      
      // Get contract owner
      const ownerResult = await provider.request({
        method: 'eth_call',
        params: [{
          to: CONTRACT_CONFIG.darkpoolPerpDEX,
          data: CONTRACT_ABI.owner,
        }, 'latest'],
      });
      
      console.log('Owner result:', ownerResult);
      
      // Get paused status
      const pausedResult = await provider.request({
        method: 'eth_call',
        params: [{
          to: CONTRACT_CONFIG.darkpoolPerpDEX,
          data: CONTRACT_ABI.paused,
        }, 'latest'],
      });
      
      console.log('Paused result:', pausedResult);
      
      const exists = addressCheckResult && addressCheckResult !== '0x';
      const owner = ownerResult ? `0x${ownerResult.slice(-40)}` : CONTRACT_CONFIG.darkpoolPerpDEX;
      const paused = pausedResult ? BigInt(pausedResult) > 0 : false;
      
      setState(prev => ({
        ...prev,
        systemStatus: {
          exists,
          paused,
          marketCount: 8, // Default market count
          owner,
        },
      }));
      
      console.log('System status updated:', { exists, paused, owner });
      
    } catch (error: any) {
      console.error('System status refresh error:', error);
      // Set default status on error
      setState(prev => ({
        ...prev,
        systemStatus: {
          exists: true,
          paused: false,
          marketCount: 8,
          owner: CONTRACT_CONFIG.darkpoolPerpDEX,
        },
        error: `Status refresh failed: ${error.message}`,
      }));
    }
  }, []);

  // Get stored markets
  const getStoredMarkets = useCallback(async () => {
    return Promise.resolve();
  }, []);

  // Auto-connect on mount if provider is available
  useEffect(() => {
    if (typeof window !== 'undefined' && window.ethereum) {
      window.ethereum.request({ method: 'eth_accounts' })
        .then((accounts: string[]) => {
          if (accounts.length > 0) {
            setState(prev => ({ ...prev, isConnected: true }));
            checkBalance(accounts[0]);
          }
        })
        .catch(console.error);
    }
  }, [checkBalance]);

  return {
    ...state,
    connect,
    deposit,
    withdraw,
    checkBalance,
    refreshSystemStatus,
    getStoredMarkets,
  };
};
